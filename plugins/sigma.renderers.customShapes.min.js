define([
    'sigma',
], function (sigma) {
    'use strict';

    var imageObj = {
        band: {
            url: '/img/treeview/beakers/band.png',
            clip: 1,
            scale: 1,
        },
        groupies: {
            url: '/img/treeview/beakers/groupies.png',
            clip: 1,
            scale: 1,
        },
        everyone: {
            url: '/img/treeview/beakers/everyone.png',
            clip: 1,
            scale: 1,
        }/*,
        archive: {
            url: '/img/treeview/beakers/archive.png',
            clip: 1,
            scale: 1,
        },*/
    };

    var shapes = [], ShapeLibrary;
    var register = function(name,drawShape,drawBorder) {
        shapes.push({
            'name': name,
            'drawShape': drawShape,
            'drawBorder': drawBorder
        });
    }

    var enumerateShapes = function() {
        return shapes;
    }

    /**
     * For the standard closed shapes - the shape fill and border are drawn the
     * same, with some minor differences for fill and border. To facilitate this we
     * create the generic draw functions, that take a shape drawing func and
     * return a shape-renderer/border-renderer
     * ----------
     */
    var genericDrawShape = function(shapeFunc) {
        if (shapeFunc === null) return;
        return function(node,x,y,size,color,context,settings) {
            context.fillStyle = color;
            context.beginPath();
            shapeFunc(node,x,y,size,context,settings);
            context.closePath();
            context.fill();
        };
    }

    var genericDrawBorder = function(shapeFunc) {
        if (shapeFunc === null) return;
        return function(node,x,y,size,color,context,settings) {
            context.strokeStyle = color;
            //context.lineWidth = size / 5;
            context.beginPath();
            shapeFunc(node,x,y,size,context,settings);
            context.closePath();
            context.stroke();
        };
    }

    /**
     * We now proced to use the generics to define our standard shape/border
     * drawers: square, diamond, equilateral (polygon), and star
     * ----------
     */
    var drawSquare = function(node,x,y,size,context) {
        var rotate = Math.PI*45/180; // 45 deg rotation of a diamond shape
        context.moveTo(x+size*Math.sin(rotate), y-size*Math.cos(rotate)); // first point on outer radius, dwangle 'rotate'
        for(var i=1; i<4; i++) {
            context.lineTo(x+Math.sin(rotate+2*Math.PI*i/4)*size, y-Math.cos(rotate+2*Math.PI*i/4)*size);
        }
    }
    register("square",genericDrawShape(drawSquare),genericDrawBorder(drawSquare));

    var drawRoot = function(node,x,y,size,context) {
        var rotate = Math.PI*90/180; // 45 deg rotation of a diamond shape
        context.moveTo(x+size*Math.sin(rotate), y-size*Math.cos(rotate)); // first point on outer radius, dwangle 'rotate'
        for(var i=1; i<4; i++) {
            context.lineTo(x+Math.sin(rotate+2*Math.PI*i/4)*size, y-Math.cos(rotate+2*Math.PI*i/4)*size);
        }
    }
    register("root",genericDrawShape(drawRoot),genericDrawBorder(drawRoot));

    var drawCircle = function(node,x,y,size,context) {
        context.arc(x,y,size,0,Math.PI*2,true);
    }
    register("circle",genericDrawShape(drawCircle),genericDrawBorder(drawCircle));


    var drawDefaultCircle = function(node,x,y,size,context) {
        context.beginPath();
        /*context.globalAlpha = 0.5;
        context.fillStyle = node.color;//'rgba(13, 173, 219, .1)';
        context.fillStyle.opacity = '.1';
        context.strokeStyle = node.color;//'rgb(13, 173, 219)';
        context.lineWidth   = 0.2;
        context.arc(x, y, size, 0, Math.PI*2, true);
        context.closePath();
        context.fill();
        context.stroke();

        context.globalAlpha = 0.7;
        context.beginPath();
        context.arc(x, y, size / 1.5, 0, Math.PI*2, true);
        context.fillStyle = node.color;//'rgba(13, 173, 219, .2)';
        context.fillStyle.opacity = '.2';
        context.closePath();
        context.fill();*/

        //context.globalAlpha = 1;
        context.beginPath();
        context.arc(x, y, size / 2, 0, Math.PI*2, true);
        context.fillStyle = node.color;//'black';//rgba(13, 173, 219, .2)';
        context.fillStyle.opacity = '0.5';
        context.closePath();
        context.fill();
    }
    register("defaultCircle",genericDrawShape(drawDefaultCircle),genericDrawBorder(drawDefaultCircle));


    var drawDiamond = function(node,x,y,size,context) {
        context.moveTo(x-size, y);
        context.lineTo(x, y-size);
        context.lineTo(x+size, y);
        context.lineTo(x, y+size);
    }
    register("diamond",genericDrawShape(drawDiamond),genericDrawBorder(drawDiamond));

    var drawSelectedNode = function(node,x,y,size,context,settings) {
//      context.shadowOffsetX = 0;
//      context.shadowOffsetY = 0;
//      context.shadowBlur = 22;
//      context.shadowColor = '#a1de4d';
            var color
            var renderer = sigma.canvas.nodes[node.defaultType];

            context.beginPath();
            context.arc(x, y, size + 5, 0, Math.PI*2, true);
            context.fillStyle = 'rgba(0,172,219, .2)';
            context.strokeStyle = 'rgb(0,172,219)';// + color + ')';
            context.closePath();
            context.stroke();
            context.fill();

            renderer(node, context, settings);

    }
    register("SelectedNode",genericDrawShape(drawSelectedNode),genericDrawBorder(drawSelectedNode));

    var drawBeaker = function(node,x,y,size,context) {
        if (!!node.subtype) {
            var color = node.subtype !== 'blue' ? '13, 173, 219' : '162, 219, 87'

      /*      context.beginPath();
            context.fillStyle = 'rgba(' + color + ', .1)';
            context.strokeStyle = 'rgb(' + color + ')';
            context.lineWidth   = 0.2;
//            context.arc(x, y, size, 0, Math.PI*2, true);
            context.closePath();
            context.fill();
            context.stroke();*/
        }
    }
    register("beaker",genericDrawShape(drawBeaker),genericDrawBorder(drawBeaker));

    var drawEquilateral = function(node,x,y,size,context) {
        var pcount = (node.equilateral && node.equilateral.numPoints) || 5;
        var rotate = ((node.equilateral && node.equilateral.rotate) || 0)*Math.PI/180;
        var radius = size;
        context.moveTo(x+radius*Math.sin(rotate), y-radius*Math.cos(rotate)); // first point on outer radius, angle 'rotate'
        for(var i=1; i<pcount; i++) {
            context.lineTo(x+Math.sin(rotate+2*Math.PI*i/pcount)*radius, y-Math.cos(rotate+2*Math.PI*i/pcount)*radius);
        }
    }
    register("equilateral",genericDrawShape(drawEquilateral),genericDrawBorder(drawEquilateral));


    var starShape = function(node,x,y,size,context) {
        var pcount = (node.star && node.star.numPoints) || 5,
            inRatio = (node.star && node.star.innerRatio) || 0.5,
            outR = size,
            inR = size*inRatio,
            angleOffset = Math.PI/pcount;
        context.moveTo(x, y-size); // first point on outer radius, top
        for(var i=0; i<pcount; i++) {
            context.lineTo(x+Math.sin(angleOffset+2*Math.PI*i/pcount)*inR,
                    y-Math.cos(angleOffset+2*Math.PI*i/pcount)*inR);
            context.lineTo(x+Math.sin(2*Math.PI*(i+1)/pcount)*outR,
                    y-Math.cos(2*Math.PI*(i+1)/pcount)*outR);
        }
    }
    register("star",genericDrawShape(starShape),genericDrawBorder(starShape));

    /**
     * An example of a non standard shape (pacman). Here we WILL NOT use the
     * genericDraw functions, but rather register a full custom node renderer for
     * fill, and skip the border renderer which is irrelevant for this shape
     * ----------
     */
    var drawPacman = function(node,x,y,size,color,context) {
        context.fillStyle = 'yellow';
        context.beginPath();
        context.arc(x,y,size,1.25*Math.PI,0,false);
        context.arc(x,y,size,0,0.75*Math.PI,false);
        context.lineTo(x,y);
        context.closePath();
        context.fill();

        context.fillStyle = 'white';
        context.strokeStyle = 'black';
        context.beginPath();
        context.arc(x+size/3,y-size/3,size/4,0,2*Math.PI,false);
        context.closePath();
        context.fill();
        context.stroke();

        context.fillStyle = 'black';
        context.beginPath();
        context.arc(x+4*size/9,y-size/3,size/8,0,2*Math.PI,false);
        context.closePath();
        context.fill();
    }
    register("pacman",drawPacman,null);

    /**
     * Exporting
     * ----------
     */
    ShapeLibrary = {

        // Functions
        enumerate: enumerateShapes,
        // add: addShape,

        // Version
        version: '0.1'
    };

    if (typeof sigma === 'undefined')
        throw 'sigma is not declared';

    if (typeof ShapeLibrary === 'undefined')
        throw 'ShapeLibrary is not declared';


    // Initialize package:
    sigma.utils.pkg('sigma.canvas.nodes');

    var sigInst = undefined;
    var imgCache = {};

    var initPlugin = function(inst) {
        sigInst = inst;
    }

    var drawImage = function (node,x,y,size,context) {
        if ( Boolean(node.publishType) ) {
            node.image = imageObj[node.publishType];
        }

        if((sigInst && node.image && node.image.url) ) {

            var url = node.image.url;
            var ih = node.image.h || 1; // 1 is arbitrary, anyway only the ratio counts
            var iw = node.image.w || 1;
            var scale = node.image.scale || 1;
            var clip = node.image.clip || 1;

            // create new IMG or get from imgCache
            var image = imgCache[url];
            if(!image) {
                image = document.createElement('IMG');
                image.src = url;
                image.onload = function(){
                    // TODO see how we redraw on load
                    // need to provide the siginst as a parameter to the library
                    console.log("redraw on image load");
                    sigInst.refresh();
                };
                imgCache[url] = image;
            }

            // calculate position and draw
            var xratio = (iw<ih) ? (iw/ih) : 1;
            var yratio = (ih<iw) ? (ih/iw) : 1;
            var r = size*scale;

            // Draw the clipping disc:
            context.save(); // enter clipping mode
    /*        context.beginPath();
            context.arc(x,y,size*clip,0,Math.PI*2,true);
            context.closePath();
            context.clip();*/

            // Draw the actual image
            context.drawImage(image,
                    x+Math.sin(-3.142/4)*r*xratio,
                    y-Math.cos(-3.142/4)*r*yratio,
                    r*xratio*2*Math.sin(-3.142/4)*(-1),
                    r*yratio*2*Math.cos(-3.142/4));
            context.restore(); // exit clipping mode
        }
    }


    var register = function(name,drawShape,drawBorder) {
        sigma.canvas.nodes[name] = function(node, context, settings) {
            var args = arguments,
                prefix = settings('prefix') || '',
                size = node[prefix + 'size'],
                color = node.color || settings('defaultNodeColor'),
                borderColor = node.borderColor || color,
                x = node[prefix + 'x'],
                y = node[prefix + 'y'];

            context.save();

            if(drawShape) {
                drawShape(node,x,y,size,color,context,settings);
            }

            if(drawBorder) {
                drawBorder(node,x,y,size,borderColor,context,settings);
            }

            drawImage(node,x,y,size,context);

            context.restore();
        };
    }

    ShapeLibrary.enumerate().forEach(function(shape) {
        register(shape.name,shape.drawShape,shape.drawBorder);
    });

    /**
     * Exporting
     * ----------
     */
    return {

        // Functions
        init: initPlugin,
        // add pre-cache images

        // Version
        version: '0.1'
    };

});
